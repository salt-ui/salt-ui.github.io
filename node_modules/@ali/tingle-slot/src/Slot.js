/**
 * Slot Component for tingle
 * @author caoke.ck
 *
 * Copyright 2014-2016, Tingle Team.
 * All rights reserved.
 */

const React = require('react');
const classnames = require('classnames');
const Context = require('@ali/tingle-context');
const Layer = require('@ali/tingle-layer');
const Scroller = require('@ali/tingle-scroller');

// 滑动效果的动画函数
const LINEAR_EASE = {
    style: 'linear',
    fn: (k) => k
};

let isArray = (arr) => Object.prototype.toString.call(arr) === '[object Array]';
let equals = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);

class Slot extends React.Component {

    constructor(props) {
        super(props);

        let t = this;

        // 初始状态
        t.state = {
            visible: false,
            title: props.title || '',
            data: props.data || [],
            selectedIndex: t.findSelectedIndex(props)
        };
    }

    componentDidMount() {
        let t = this;

        // 获取所有 scroller 的容器
        let slotBody = t.refs.root.querySelector(`.${Context.prefixClass('slot-body')}`);

        // 获取选项高度
        t.findItemHeight(slotBody);

        // tap 事件触发选中状态变更
        slotBody.addEventListener('iscroll:tap', function(e) {
            let className = e.target.className;
            var reg = new RegExp(Context.prefixClass('slot-item(\\d+)_(\\d+)'));
            let match = reg.exec(className);
            if (match && className.indexOf(Context.prefixClass('slot-item-active')) === -1) {
                let column = parseInt(match[1]);
                let index = parseInt(match[2]);
                t.props.onChange(t.getData(column, index), column, index);
            }
        }, false);

        // 初始化滚动的标记
        t._willRefresh = true;
    }

    componentDidUpdate() {
        let t = this;

        // 获取选项高度
        t.findItemHeight();

        // 可见的时候滚动到选中的选项
        if (t.state.visible && t._willRefresh) {

            t._willRefresh = false;
            t.scrollAll(200);
        }
    }

    // 减少渲染次数
    componentWillReceiveProps(nextProps) {
        let t = this;

        let data = nextProps.data;
        let selectedIndex = t.findSelectedIndex(nextProps);

        // 数据变化需要重新初始化 scroller
        let state = {};
        let willRefresh = false;
        if (!equals(t.state.data, data)) {
            state.data = data;
            if (t.props.scrollMod == 'keep') { // 替换列后仍保留指定值的位置
                // 记录旧值在新数据中的索引
                t._selectedIndex = t.findSelectedIndex({
                    data: data,
                    value: t.state.selectedIndex.map(function(n, i) {
                        return t.state.data[i][n];
                    })
                });
                // 标记变更的列
                t._columnChanged = t.state.data.map(function(n, i) {
                    return !equals(data[i], n);
                });
            }
            willRefresh = true;
        }
        if (!equals(t.state.selectedIndex, selectedIndex)) {
            state.selectedIndex = selectedIndex;
            willRefresh = true;
        }
        if (willRefresh) {
            t._willRefresh = true;
            t.setState(state);
        }
    }

    findItemHeight(slotBody) {
        let t = this;
        if (!t._itemHeight) {
            slotBody = slotBody || t.refs.root.querySelector(`.${Context.prefixClass('slot-body')}`);
            let li = slotBody.querySelector('li');
            t._itemHeight = li ? parseFloat(getComputedStyle(li, null).height) : 0;
        }
    }

    scrollAll(time) {
        let t = this;
        if (t.props.scrollMod == 'keep' && t._selectedIndex) {
            t._selectedIndex.forEach(function(index, column) {
                let scroller = t.refs[`scroller${column}`].scroller;
                if (t._columnChanged[column]) {
                    scroller.scrollTo(0, -index * t._itemHeight, 0, LINEAR_EASE);
                }
            });
            delete t._selectedIndex;
            setTimeout(function() {
                t.state.selectedIndex.forEach(function(index, column) {
                    let scroller = t.refs[`scroller${column}`].scroller;
                    scroller.scrollTo(0, -index * t._itemHeight, time, LINEAR_EASE);
                });
            }, 5);
        } else {
            t.state.selectedIndex.forEach(function(index, column) {
                let scroller = t.refs[`scroller${column}`].scroller;
                scroller.scrollTo(0, -index * t._itemHeight, time, LINEAR_EASE);
            });
        }
    }

    findSelectedIndex(props) {
        let data = props.data || [];
        let value = props.value || [];
        let selectedIndex = [];

        // 遍历数据模型
        data.forEach(function(columnData, column) {

            selectedIndex[column] = 0;

            // 遍历每一列
            for (let i = 0; i < columnData.length; i++) {

                // 定位选中值
                if (value[column] && columnData[i].value === value[column].value) {
                    selectedIndex[column] = i;
                    break;
                }
            }
        });

        return selectedIndex;
    }

    handleScrollStart() {
        let t = this;
        t.setState({
            scrolling: true
        });
    }

    handleScrollEnd(column) {
        let t = this;
        t.setState({
            scrolling: false
        });
        let scroller = t.refs[`scroller${column}`].scroller;
        let height = t._itemHeight;
        let remainder = Math.abs(scroller.y % height);
        let index = scroller.y / height;

        // 没有滚动到选项，需要继续滚动一段距离
        if (remainder) {

            let func;
            if (scroller.distY > 0) { // 向下滚动
                if (remainder < height * 0.7) {
                    func = 'ceil';
                } else {
                    func = 'floor';
                }
            } else { // 向上滚动
                if (remainder > height * 0.3) {
                    func = 'floor';
                } else {
                    func = 'ceil';
                }
            }

            index = Math[func](scroller.y / height);
        }

        // 在 onChange 中设置状态
        index = Math.abs(index);
        t.props.onChange(t.getData(column, index), column, index);
    }

    show() {
        this.setState({
            visible: true
        }, () => {
            this.scrollAll(0);
        });
    }

    hide() {
        this.setState({
            visible: false
        });
    }

    handleCancel() {
        let t = this;
        if (t.state.scrolling) {
            return false;
        }

        try {
            t.props.onCancel();
        } finally {
            t.hide();
        }
    }

    handleConfirm() {
        let t = this;
        if (t.state.scrolling) {
            return false;
        }

        try {
            t.props.onConfirm(t.getData());
        } finally {
            t.hide();
        }
    }

    // 获取值的时候指定变更的列，为什么要这么做，是因为有变更后我不直接改 state！
    getData(sColumn, sIndex) {
        let t = this;
        let ret = [];
        let { data, selectedIndex } = t.state;

        selectedIndex.forEach(function(index, column) {
            ret[column] = data[column][column === sColumn ? sIndex : index];
        });

        return ret;
    }

    render() {
        let t = this;
        let { className, maskCloseable, cancelText, confirmText } = t.props;
        return (
            <Layer visible={t.state.visible} bottom={0} onMaskClick={maskCloseable ? t.handleCancel.bind(t) : (() => maskCloseable)}>
                <div ref="root" className={classnames(Context.prefixClass('slot'), {
                    [className]: !!className
                })}>
                    <div className={Context.prefixClass('slot-header FBH FBAC')}>
                        <div className={Context.prefixClass('slot-cancel')} onClick={t.handleCancel.bind(t)}>{cancelText}</div>
                        <div className={Context.prefixClass('FB1 FAC slot-title')}>{t.state.title}</div>
                        <div className={classnames(Context.prefixClass('slot-confirm'), {
                            enable: !t.state.scrolling
                        })}  onClick={t.handleConfirm.bind(t)}>{confirmText}</div>
                    </div>
                    {t.props.columns && t.props.columns.length ? (
                        <ul className={Context.prefixClass('slot-columns FBH')}>
                        {t.props.columns.map((c, i) => {
                            return (
                                <li key={`column${i}`} className={Context.prefixClass('FB1 FAC')}>{c}</li>
                            );
                        })}
                        </ul>
                    ) : ''}
                    <div className={Context.prefixClass('slot-body FBH FC9 PR')}>
                        {t.state.data.map(function(m, i) {
                            return (
                                <Scroller ref={`scroller${i}`} key={`scroller${i}`} className={Context.prefixClass('FB1')} autoRefresh={t.state.visible} tap="iscroll:tap" onScrollStart={t.handleScrollStart.bind(t, i)} onScrollEnd={t.handleScrollEnd.bind(t, i)}>
                                    <ul>
                                        <li></li>
                                        <li></li>
                                        {m.map(function(n, j) {
                                            return (
                                                <li key={`item${i}_${j}`} className={classnames(Context.prefixClass(`slot-item${i}_${j}`), {
                                                    [ Context.prefixClass('slot-item-active') ]: j === t.state.selectedIndex[i]
                                                })}>{n.text}</li>
                                            );
                                        })}
                                        <li></li>
                                        <li></li>
                                    </ul>
                                </Scroller>
                            );
                        })}
                    </div>
                </div>
            </Layer>
        )
    }
}

Slot.defaultProps = {
    title: '',
    value: [],
    maskCloseable: true,
    data:[],
    className:'',
    confirmText: '完成',
    cancelText: '取消',
    onConfirm() {},
    onCancel() {},
    onChange() {},
    scrollMod: 'reset',
    columns: []
};

// http://facebook.github.io/react/docs/reusable-components.html
Slot.propTypes = {
    className: React.PropTypes.string,
    title: React.PropTypes.string,
    data: React.PropTypes.array.isRequired,
    value: React.PropTypes.array,
    maskCloseable: React.PropTypes.bool,
    confirmText: React.PropTypes.string,
    cancelText: React.PropTypes.string,
    onConfirm: React.PropTypes.func,
    onCancel: React.PropTypes.func,
    onChange: React.PropTypes.func,
    scrollMod: React.PropTypes.string,
    columns: React.PropTypes.array
};

// 格式化单列数据
Slot.formatColumnValue = function(columnData, value) {

    // 兼容简单选中值
    let columnValue;
    if (typeof value !== 'undefined') {
        if (value.hasOwnProperty('value')) {
            columnValue = value.value;
        } else {
            columnValue = value;
        }
    }
    value = undefined;

    // 遍历每一项
    for (let i = 0; i < columnData.length; i++) {
        let cell = columnData[i];

        // 兼容非对象的数据
        if (typeof cell !== 'object') {
            cell = columnData[i] = {
                text: cell,
                value: cell
            };
        }

        // 补全缺失数据
        if (!cell.hasOwnProperty('text')) {
            cell.text = cell.value;
        }
        if (!cell.hasOwnProperty('value')) {
            cell.value = cell.text;
        }

        // 定位选中值
        if (cell.value === columnValue) {
            value = cell;
        }
    }

    // 默认选中第一项
    if (typeof value !== 'object') {
        value = columnData[0];
    }

    return {
        columnData: columnData,
        columnValue: value
    }
};

// 格式化多列数据
Slot.formatDataValue = function(data = [], value = []) {

    // 兼容单列数据的缩略写法
    if (!isArray(data[0])) {
        data = [ data ];
    }
    if (!isArray(value)) {
        value = [ value ];
    }

    // 遍历数据模型
    data.forEach(function(columnData, column) {

        // 格式化列数据
        let ret = Slot.formatColumnValue(columnData, value[column]);
        value[column] = ret.columnValue;
    });

    return {
        data: data,
        value: value
    };
};

Slot.displayName = 'Slot';

module.exports = Slot;
