'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var R = require('ramda');
var exist = require('exist.js');
var join = require('path').join;

function hasParams(path) {
  return path.split('/').some(function (snippet) {
    return snippet.startsWith(':');
  });
}

function has404(filesPath) {
  return filesPath.indexOf('/404.html') >= 0;
}

function flattenRoutes(routes) {
  var flattenedRoutes = [];
  (Array.isArray(routes) ? routes : [routes]).forEach(function (item) {
    var copy = Object.assign({}, item);
    if (!copy.dataPath) {
      copy.dataPath = copy.path;
    }
    flattenedRoutes.push(copy);

    if (item.childRoutes) {
      var nestedRoutes = R.chain(flattenRoutes, item.childRoutes.map(function (child) {
        return Object.assign({}, child, {
          path: join(item.path, child.path)
        });
      }));
      flattenedRoutes = flattenedRoutes.concat(nestedRoutes);
    }
  });
  return flattenedRoutes;
}

module.exports = function generateFilesPath(routes, markdown) {
  var flattenedRoutes = flattenRoutes(routes);

  var filesPath = R.chain(function (item) {
    if (hasParams(item.path)) {
      var _ret = function () {
        var dataPathSnippets = item.dataPath.split('/').slice(1);
        var firstParamIndex = dataPathSnippets.findIndex(function (snippet) {
          return snippet.startsWith(':');
        });
        var firstParam = dataPathSnippets[firstParamIndex];

        var dataSet = exist.get(markdown, dataPathSnippets.slice(0, firstParamIndex), {});
        var processedCompleteRoutes = Object.keys(dataSet).map(function (key) {
          var pathSnippet = key.replace(/\.md/, '');
          var path = item.path.replace(firstParam, pathSnippet);
          var dataPath = item.dataPath.replace(firstParam, pathSnippet);
          return { path: path, dataPath: dataPath };
        });

        return {
          v: generateFilesPath(processedCompleteRoutes, markdown)
        };
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    } else if (item.path.endsWith('/')) {
      return [item.path + 'index.html'];
    }
    return [item.path + '.html'];
  }, flattenedRoutes);

  return has404(filesPath) ? filesPath : filesPath.concat('/404.html');
};